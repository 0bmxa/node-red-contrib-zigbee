<!DOCTYPE html>
<head><script type="text/javascript" src="../vis/vis.min.js"></script>
<link href="../vis/vis.min.css" type="text/css">
<style>
    html, body {
        height: 100%;
        font-family: arial;
        margin: 0;
        padding: 0;
    }
    h4 {
        margin: 6px;
    }
    #map {
        height: calc(100% - 30px);
    }
    #loader {
        position: absolute;
        top: 50px;
        left: calc(50% - 64px);
    }
</style>
</head><body>
<h4>ZigBee Network Map</h4>
<div id="loader"><img src="loader.gif" id="loader"><br><span id="status"></span></div>
<div id="map"></div>


<script type="text/javascript">
    const container = document.querySelector('#map');

    let devices;
    const routes = [];
    const routesMap = {};

    const knownDevices = [];

    const $status = document.querySelector('#status');

    fetch('../devices' + window.location.search)
        .then(response => {
            return response.json();
        })
        .then(data => {
            devices = data;
            devices.forEach(device => {
                knownDevices.push(device.ieeeAddr);
            });
            console.log('devices', devices);
        })
        .then(getRtg)
        .then(getLqi)
        .catch(err => {
            container.innerHTML = err.message;
        })
        .finally(() => {
            document.querySelector('#loader').remove();
            createGraph();
        });

    function getRtg() {
        return new Promise(resolve => {
            const tasks = [];
            devices.forEach(device => {
                if (device.type === 'EndDevice') {
                    return;
                }

                tasks.push(() => {
                    return new Promise(resolve => {
                        console.log('get routing table of ' + device.ieeeAddr + ' ' + device.meta.name);
                        $status.innerHTML = 'get routing table of ' + device.ieeeAddr + ' ' + device.meta.name;

                        fetch('../getRoutingTable' + window.location.search + '&ieeeAddr=' + device.ieeeAddr)
                            .then(response => {
                                return response.json();
                            })
                            .then(data => {
                                console.log('getRoutingTable', device.ieeeAddr, data);
                                data.forEach(route => {
                                    const id = device.ieeeAddr + '|' + route.nextHop;
                                    if (routesMap[id]) {
                                        routesMap[id].count += 1;
                                        routesMap[id].status = route.status;
                                    } else {
                                        routesMap[id] = {
                                            sourceIeeeAddr: device.ieeeAddr,
                                            targetIeeeAddr: getIeeeAddr(route.nextHop === 65534 ? route.destinationAddress : route.nextHop),
                                            routeStatus: route.routeStatus,
                                            count: 1
                                        };
                                    }
                                });
                            })
                            .finally(resolve);
                    });
                });
            });

            function shiftTasks() {
                if (tasks.length > 0) {
                    const task = tasks.shift();
                    task().then(shiftTasks);
                } else {
                    console.log('routesMap', routesMap);
                    resolve();
                }
            }

            shiftTasks();
        });
    }

    function getLqi() {
        return new Promise(resolve => {
            const tasks = [];
            devices.forEach(device => {
                if (device.type === 'EndDevice') {
                    return;
                }

                tasks.push(() => {
                    return new Promise(resolve => {
                        console.log('get lqi list of ' + device.ieeeAddr + ' ' + device.meta.name);
                        $status.innerHTML = 'get lqi list of ' + device.ieeeAddr + ' ' + device.meta.name;

                        fetch('../getLqi' + window.location.search + '&ieeeAddr=' + device.ieeeAddr)
                            .then(response => {
                                return response.json();
                            })
                            .then(data => {
                                console.log('getLqi', device.ieeeAddr, data);
                                data.forEach(neighbour => {
                                    /*
                                    if (!knownDevices.includes(neighbour.ieeeAddr)) {
                                        devices.push({
                                            ieeeAddr: neighbour.ieeeAddr,
                                            foreign: true,
                                            meta: {}
                                        });
                                        knownDevices.push(neighbour.ieeeAddr);
                                    }
                                    */
                                    const id = device.ieeeAddr + '|' + neighbour.networkAddress;
                                    if (routesMap[id]) {
                                        if (knownDevices.includes(neighbour.ieeeAddr)) {
                                            routesMap[id].count += 1;
                                        }

                                        routesMap[id].lqi = neighbour.linkquality;
                                        routesMap[id].depth = neighbour.depth;
                                        routesMap[id].relationship = neighbour.relationship;
                                    } else {
                                        routesMap[id] = {
                                            sourceIeeeAddr: device.ieeeAddr,
                                            targetIeeeAddr: neighbour.ieeeAddr,
                                            routeStatus: 0,
                                            relationship: neighbour.relationship,
                                            depth: neighbour.depth,
                                            lqi: neighbour.linkquality,
                                            count: 1
                                        };
                                    }
                                });
                            })
                            .finally(resolve);
                    });
                });
            });

            function shiftTasks() {
                if (tasks.length > 0) {
                    const task = tasks.shift();
                    task().then(shiftTasks);
                } else {
                    console.log('routesMap', routesMap);
                    Object.keys(routesMap).forEach(id => {
                        routes.push(routesMap[id]);
                    });
                    resolve();
                }
            }

            shiftTasks();
        });

        /*

        document.querySelector('#status').innerHTML = 'get lqi lists...';
        return fetch('../lqiScan' + window.location.search)
            .then(response => {
                return response.json();
            })
            .then(data => {
                console.log('lqiScan', data);

                Object.keys(data).forEach(sourceIeeeAddr => {
                    data[sourceIeeeAddr].forEach(neighbour => {
                        if (!knownDevices.includes(neighbour.ieeeAddr)) {
                            devices.push({
                                ieeeAddr: neighbour.ieeeAddr,
                                foreign: true,
                                meta: {}
                            });
                            knownDevices.push(neighbour.ieeeAddr)
                        }

                        const id = sourceIeeeAddr + '|' + neighbour.networkAddress;
                        if (routesMap[id]) {
                            if (knownDevices.includes(neighbour.ieeeAddr)) {
                                routesMap[id].count += 1;
                            }

                            routesMap[id].lqi = neighbour.linkquality;
                            routesMap[id].depth = neighbour.depth;
                            routesMap[id].relationship = neighbour.relationship;
                        } else {
                            routesMap[id] = {
                                sourceIeeeAddr,
                                targetIeeeAddr: neighbour.ieeeAddr,
                                routeStatus: 0,
                                relationship: neighbour.relationship,
                                depth: neighbour.depth,
                                lqi: neighbour.linkquality,
                                count: 1
                            };
                        }
                    });
                });

                console.log('routesMap', routesMap);
                Object.keys(routesMap).forEach(id => {
                    routes.push(routesMap[id]);
                });
            });*/
    }

    function getIeeeAddr(nwkAddr) {
        const devs = devices.filter(device => device.networkAddress === nwkAddr);
        if (devs.length === 1) {
            return devs[0].ieeeAddr;
        }
    }

    function createGraph() {
        //let coordAddr;
        console.log('routes', routes);
        const routesData = routes.map(route => {
            return {
                to: route.targetIeeeAddr,
                from: route.sourceIeeeAddr,
                label: rssi(route.lqi),
                arrows: 'from',
                dashes: typeof route.lqi === 'undefined',
                color: {inherit: 'to'},
                font: {
                    color: 'rgba(0,0,0,0)'
                },
                chosen: {
                    label: values => {
                        values.color = {inherit: 'to'};
                        values.mod = 'bold';
                    }
                }
            };
        });

        console.log(routesData);

        const data = {
            nodes: new vis.DataSet(devices.map(dev => {
                const isCoord = dev.type === 'Coordinator';
                const isBattery = dev.powerSource === 'Battery';
                const id = dev.ieeeAddr;

                const isOffline = dev.meta.offline === true;
                const children = routes.filter(pair => pair.sourceIeeeAddr === dev.ieeeAddr).length;
                const label = [
                    dev.meta.name,
                    dev.type,
                    dev.ieeeAddr,
                    dev.manufacturerName,
                    dev.modelID,
                    dev.powerSource,
                    children ? 'Children: ' + children + (isCoord ? (' (' + devices.length + ')') : '') : ''
                ].filter(v => v).join('\n');

                return {
                    id,
                    label,
                    shape: children ? 'circle' : 'box',
                    shapeProperties: {
                        borderDashes: isOffline
                    },
                    color: {
                        background: dev.foreign ? '#eee' : isCoord ? '#B2DC96' : (isBattery ? '#E5F2FF' : '#D2E5FF'),
                        border: dev.foreign ? '#ccc' : isCoord ? '#028C76' : (isBattery ? '#3386E9' : '#2B7CE9'),
                        highlight: {
                            background: dev.foreign ? '#eee' : isCoord ? '#B2DC96' : (isBattery ? '#D2E5FF' : '#D2E5FF'),
                            border: dev.foreign ? '#aaa' : isCoord ? '#028C76' : (isBattery ? '#2B7CE9' : '#2B7CE9')
                        }
                    }
                    //mass: isCoord ? 1.0 : (isRouter ? 1.02 : (isOffline ? 1.035 : 1.025))

                };
            })),

            edges: new vis.DataSet(routesData)
        };

        const options = {
            layout: {
                //hierarchical: true
            },
            physics: {
                stabilization: true,
                solver: 'forceAtlas2Based',
                forceAtlas2Based: {
                    avoidOverlap: 0.00005
                },
                barnesHut: {
                    gravitationalConstant: -2000,
                    centralGravity: 0.37,
                    springLength: 89,
                    springConstant: 0.02,
                    damping: 0.09,
                    avoidOverlap: 0.25
                }
            }
        };

        const network = new vis.Network(container, data, options); // eslint-disable-line no-unused-vars
    }

    /*
        lqi => rssi
        https://e2e.ti.com/support/wireless-connectivity/zigbee-and-thread/f/158/t/555076?How-to-get-rssi-value-from-Z-Stack-Linux-Gateway-
        RSSI = MIN_ED+LinkQuality*( MAX_ED-MIN_ED)/255
        Default values for MIN_ED and MAX_ED are -87 and 10 respectively.
     */
    function rssi(lqi) {
        const rssi = Math.round(-87 + (lqi * 97 / 255));
        return lqi ? `${rssi} dBm\n(${lqi})` : '';
    }
</script>
</body>